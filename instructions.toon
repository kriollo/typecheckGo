project: TS_Typechecker_Go
description:
  "Roadmap pr√°ctico: construir un typechecker de TypeScript en Go.
   Empieza simple, itera, agrega features avanzadas por fases.
   Cada fase tiene objetivos, entregables y criterios de aceptaci√≥n."


phases[5]{name, duration_weeks, goals, deliverables, acceptance}:
  - Basico,4: ‚úÖ COMPLETADO
      goals:
        - ‚úÖ "Parser + AST estable (usar parser existente)." - Implementado parser recursivo propio con soporte completo: funciones, variables, if statements, expresiones binarias, imports/exports, template strings
        - ‚úÖ "Tabla de s√≠mbolos simple (variables, funciones, imports)." - Tabla de s√≠mbolos con scopes jer√°rquicos implementada
        - ‚úÖ "Resoluci√≥n de m√≥dulos ES/TS (imports/exports)." - Sistema de resoluci√≥n de m√≥dulos con algoritmo Node.js implementado, exports e imports funcionando correctamente, soporte para .js ‚Üí .ts
        - ‚úÖ "Checks sint√°cticos y errores b√°sicos (tipo: errores de nombre y aridad)." - Implementados checks de nombres no definidos y validaci√≥n de aridad en funciones
      deliverables:
        - ‚úÖ "CLI minimal: check <path> -> lista de errores." - CLI implementado con comando check
        - ‚úÖ "AST output en JSON/TOON para debugging." - Formatos JSON y TOON implementados
      acceptance:
        - ‚úÖ "Procesa proyectos de ejemplo peque√±os; detecta nombres no definidos y funciones llamadas con distinto arity." - Funcionando correctamente con archivos de prueba

      fixes_applied:
        - "‚úÖ Loop infinito con template strings - agregado soporte para backticks y interpolaci√≥n ${}"
        - "‚úÖ Tipo de retorno en funciones - parser ahora maneja anotaciones : Type"
        - "‚úÖ Resoluci√≥n .js ‚Üí .ts - imports con .js encuentran archivos .ts autom√°ticamente"
        - "‚úÖ S√≠mbolos importados disponibles - processImports() agrega s√≠mbolos al scope"
        - "‚úÖ Tipo correcto de imports - funciones importadas se marcan como FunctionSymbol"
        - "‚úÖ Export { name } encuentra declaraciones originales en el m√≥dulo"

  - Intermedio,8: üîÑ EN PROGRESO
      goals:
        - üîÑ "Sistema de tipos b√°sico: primitivos, objetos planos, funciones, arrays, uniones simples."
        - üîÑ "Type inference local (vars, return)."
        - ‚è≥ "Control-flow based narrowing (if typeof / instanceof / null checks) b√°sico."
        - ‚è≥ "M√≥dulos y tipos exportados/importados correctamente tipados."
      deliverables:
        - ‚è≥ "Graph de dependencias incremental."
        - ‚è≥ "Cache por archivo con hashes y timestamps."
        - üîÑ "Reporte de errores con c√≥digo y span." - Parcialmente implementado
      acceptance:
        - ‚è≥ "Projectos medianos (~10k LOC) checkean r√°pido con cache incremental (rechecks locales)."

      next_tasks:
        - "Implementar sistema de tipos b√°sico (TypeID pool, primitivos: string, number, boolean, any, unknown, void)"
        - "Agregar objetos globales (console, Object, Array, etc.)"
        - "Type inference para variables con inicializador"
        - "Type inference para return statements"
        - "Validaci√≥n de tipos en asignaciones y operaciones binarias"
        - "Soporte para arrays y objetos literales"
        - "Union types b√°sicos"

  - Avanzado,12:
      goals:
        - "Soporte para: generics, mapped types, conditional types (nivel 1), type aliases, intersection, distributive unions parcial."
        - "Resoluci√≥n de overloads y contextual typing b√°sico."
        - "Inference m√°s profunda en funciones gen√©ricas simples."
        - "Integraci√≥n con go routine workers para an√°lisis paralelo por m√≥dulos."
      deliverables:
        - "Motor de inferencia por capas (local -> module -> global)."
        - "Pruebas de compatibilidad con patterns comunes de TS (React props, libs comunes)."
      acceptance:
        - "Cobertura de features usadas por 80% de repos p√∫blicos objetivo (seg√∫n tu corpus)."

  - Pro,20:
      goals:
        - "Soporte avanzado: template literal types (parcial), infer en conditional types (limitado), declaration merging y namespace handling."
        - "Compatibilidad con .d.ts parsing y conversion simple."
        - "API LSP: diagnostics, hover, goto, incremental edits."
        - "Optimizaci√≥n: mem-profiler, GC tuning, lockless caches."
      deliverables:
        - "Server LSP estable + benchmarks con proyectos reales."
        - "Compat mode: marcar diagn√≥sticos con nivel 'strictness' para decidir qu√© reportar."
      acceptance:
        - "LSP adoptable por VSCode; tiempo de cold-check en grandes mono-repo < objetivo (seg√∫n tu SLA)."

  - Edge/Opt,ongoing:
      goals:
        - "Paridad completa con TypeScript (si decides), reimplementaci√≥n de corner-cases."
        - "Estrategias de fallback: delegar checks complejos al `tsserver` cuando no se quiere implementar."
        - "Soporte multiplataforma binario, cross-compile, CI/CD."
      deliverables:
        - "Modo h√≠brido: fast-checker + fallback RPC a tsserver."
        - "Documentaci√≥n y gu√≠a de migraci√≥n."
      acceptance:
        - "Adopci√≥n incremental posible sin romper pipelines existentes."

data_structures:
  symbol_table:
    - "Scoped maps: module -> scope tree -> symbol entries (name,type,node,mutability,declSpan)."
    - "Support for hoisting flags y temporal bindings para `var`/`let`."
  type:
    - "TypeID (int) referenciando un pool de tipos para deduplicar."
    - "Union/Intersection como sets de TypeID."
    - "Generic type with params + instantiated cache (map[signature] -> instantiation)."
  graph:
    - "Dependency DAG por m√≥dulo con strong/weak edges (reexports, types-only)."
    - "Change propagation via topo-order incremental re-eval."

algorithms:
  parsing: "usar parser existente (oxc, swc) y transformar AST a tu IR Go. NO reescribir desde 0."
  inference:
    - "two-phase: gather shapes -> unify -> finalize"
    - "union widening heuristics para evitar explosi√≥n exponencial"
  constraint_solver:
    - "worklist algorithm con monotonic fixation y timeout/costo por nodo"
  incremental:
    - "file-hash -> dirty-set -> affected-subgraph -> recheck minimal"
    - "cache serialized TypeIDs + symbol snapshots para warm-start"

concurrency:
  - "Worker pool por CPU cores - evitar shared mutable state; comunicar con channels immutable messages."
  - "Shard por m√≥dulos o por grupos de archivos (split por entry points)."
  - "Lockless read caches + version numbers para invalidation."

interop:
  - "Emit JSON/TOON diagnostics compatible con editors y CI."
  - "Mode 'check-only' y mode 'lsp-server' para integraci√≥n."
  - "Fallback RPC: si feature X no soportada -> llamar tsserver para ese file/diagnostic."

testing:
  - "Corpus de test: fixtures reales (react, node libs), fuzz inputs y .d.ts cribado."
  - "Benchmarks: cold vs warm, incremental single-file change, multi-file change."
  - "Define P0/P1/P2 test suites; tests de performance y memoria automatizados."

observability:
  - "Tracing por pass (parse, bind, infer, finalize)."
  - "Metrics: files/s, types_resolved/s, GC-perc, peak_rss."
  - "Modo verbose con span tree para debug."

deliverables_and_milestones:
  - "M1 (4w): CLI + parser + symbol table + basic checks."
  - "M2 (12w): inference b√°sico + incremental cache + worker pool."
  - "M3 (24w): generics + LSP prototype + benchmarks."
  - "M4 (48w): advanced types + fallback mode + production LSP."

risks_and_mitigations:
  - "R: explosion en conditional/template types -> M: cap heuristics y fallback a tsserver."
  - "R: mismatch con ecosistema TS -> M: soporte .d.ts + tests contra bundles reales."
  - "R: tiempo de desarrollo -> M: priorizar features que impactan UX y perf antes que paridad."

implementation_notes:
  - "Lang: Go 1.21+ (por performance y generics)."
  - "Start: write small prototypes in Go quickly: parser adapter -> AST -> binder."
  - "Tooling: use pprof, go test -bench, go vet y fuzzing para encontrar regresiones."
  - "Docs: version the diagnostics and include 'compatibility level' flags."

examples[2]{name, toon}:
  - "AST debug example",
    "```toon\nnodes[2]{id,type,span}:\n  1,FunctionDecl,1:0-1:24\n  2,ReturnStmt,1:10-1:24\n```"
  - "Diagnostics example",
    "```toon\ndiags[1]{file,line,col,msg,code,severity}:\n  main.ts,12,5,\"Property 'x' does not exist on type 'Foo'\",TS2339,error\n```"

next_steps:
  - "Implement adapter a parser existente (oxc/swc) ‚Äî 1 semana."
  - "Dise√±ar symbol table y APIs internas (2-3 d√≠as)."
  - "Prototipo minimal CLI que corra checks b√°sicos (2 semanas)."
